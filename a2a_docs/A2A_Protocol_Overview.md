# Agent-to-Agent (A2A) Protocol Specification

## Overview

The Agent-to-Agent (A2A) Protocol is an open standard for communication between independent AI agent systems, enabling agents to discover capabilities, negotiate interactions, and collaborate on tasks in an interoperable, flexible, and enterprise-ready manner.

## Core Architecture

### Communication Model
- **Transport**: HTTP(S) with JSON-RPC 2.0
- **Client Role**: A2A Client initiates requests on behalf of users
- **Server Role**: A2A Server (Remote Agent) processes tasks and provides responses
- **Security**: HTTPS required, multiple authentication schemes supported

### Key Components

#### 1. Agent Card
Metadata describing an agent's identity, capabilities, and skills:
```json
{
  "name": "Assistant Agent",
  "description": "A helpful AI assistant",
  "version": "1.0.0",
  "capabilities": ["text_processing", "task_planning"],
  "skills": [
    {
      "name": "text_analysis",
      "description": "Analyzes text content",
      "parameters": { /* JSON Schema */ }
    }
  ]
}
```

#### 2. Task
Fundamental unit of work with lifecycle management:
- Unique task ID for tracking
- Status tracking (pending, running, completed, failed, cancelled)
- Support for multi-turn interactions
- Input/output message handling

#### 3. Message
Communication turn between agents:
```json
{
  "id": "msg_123",
  "task_id": "task_456",
  "parts": [
    {
      "type": "text",
      "content": "Process this data"
    },
    {
      "type": "file",
      "name": "data.json",
      "mime_type": "application/json",
      "content": "base64_encoded_content"
    }
  ]
}
```

#### 4. Artifact
Output generated by an agent during task execution:
```json
{
  "id": "artifact_789",
  "task_id": "task_456", 
  "type": "result",
  "content": "Processed data result",
  "metadata": {
    "created_at": "2024-01-01T00:00:00Z",
    "format": "text/plain"
  }
}
```

## Communication Patterns

### 1. Synchronous Request/Response
- **Endpoint**: `message/send`
- Simple, immediate interactions
- Polling for task status using `tasks/get`
- Suitable for quick operations

### 2. Streaming (Server-Sent Events)
- **Endpoint**: `message/stream`
- Real-time updates during task execution
- Incremental artifact generation
- Task status change notifications
- Ideal for long-running tasks with intermediate results

### 3. Asynchronous Interactions
- Push notifications for long-running tasks
- Multi-turn conversations requiring user input
- Webhook-based status updates
- Configuration via `tasks/pushNotificationConfig/*`

## API Endpoints

### Core Endpoints

#### `message/send`
Send a message to an agent for processing:
```json
{
  "jsonrpc": "2.0",
  "method": "message/send",
  "params": {
    "message": { /* Message object */ },
    "task_config": {
      "timeout": 30000,
      "priority": "normal"
    }
  },
  "id": "req_123"
}
```

#### `message/stream`
Streaming message send with real-time updates:
```json
{
  "jsonrpc": "2.0",
  "method": "message/stream",
  "params": {
    "message": { /* Message object */ },
    "stream_config": {
      "include_intermediates": true,
      "buffer_size": 1024
    }
  },
  "id": "req_124"
}
```

#### `tasks/get`
Retrieve task status and results:
```json
{
  "jsonrpc": "2.0",
  "method": "tasks/get",
  "params": {
    "task_id": "task_456"
  },
  "id": "req_125"
}
```

#### `tasks/cancel`
Cancel an ongoing task:
```json
{
  "jsonrpc": "2.0",
  "method": "tasks/cancel",
  "params": {
    "task_id": "task_456",
    "reason": "User cancellation"
  },
  "id": "req_126"
}
```

#### `agent/authenticatedExtendedCard`
Get detailed agent information:
```json
{
  "jsonrpc": "2.0",
  "method": "agent/authenticatedExtendedCard",
  "params": {},
  "id": "req_127"
}
```

### Push Notification Configuration

#### `tasks/pushNotificationConfig/subscribe`
Configure webhook endpoints for task updates

#### `tasks/pushNotificationConfig/unsubscribe`
Remove webhook configurations

## Authentication and Security

### Requirements
- HTTPS mandatory for all communications
- Server identity verification required
- Support for multiple authentication schemes
- Role-based access control

### Supported Authentication Methods
- OAuth 2.0 / OpenID Connect
- API Keys
- Custom authentication headers
- Out-of-band credential acquisition

### Security Features
- Request signing and verification
- Rate limiting support
- Audit logging capabilities
- Secure credential storage

## Error Handling

### JSON-RPC 2.0 Error Codes
- **-32700**: Parse error
- **-32600**: Invalid Request
- **-32601**: Method not found
- **-32602**: Invalid params
- **-32603**: Internal error

### A2A-Specific Error Codes
- **-40001**: Agent unavailable
- **-40002**: Task timeout
- **-40003**: Capability mismatch
- **-40004**: Authentication failed
- **-40005**: Resource exhausted

### Error Response Format
```json
{
  "jsonrpc": "2.0",
  "error": {
    "code": -40001,
    "message": "Agent unavailable",
    "data": {
      "agent_id": "agent_123",
      "retry_after": 30,
      "details": "Agent is currently processing maximum concurrent tasks"
    }
  },
  "id": "req_123"
}
```

## Data Models

### Message Parts
- **Text**: Plain text content
- **File**: Binary data with metadata
- **Structured Data**: JSON objects with schema validation
- **References**: Links to external resources

### Task Lifecycle States
1. **PENDING**: Task created, waiting to start
2. **RUNNING**: Task actively being processed
3. **COMPLETED**: Task finished successfully
4. **FAILED**: Task encountered an error
5. **CANCELLED**: Task was cancelled before completion

### Metadata Support
Flexible key-value metadata on all entities:
- Task metadata for context and configuration
- Message metadata for routing and processing hints
- Artifact metadata for type information and provenance

## Implementation Requirements

### Compliance Standards
- JSON-RPC 2.0 specification adherence
- HTTP/1.1 or HTTP/2 support
- UTF-8 encoding for all text content
- ISO 8601 timestamp formats

### Performance Considerations
- Connection pooling and keep-alive
- Compression support (gzip, deflate)
- Streaming response handling
- Timeout and retry mechanisms

### Interoperability
- Well-defined JSON schemas for all data structures
- Version negotiation support
- Capability discovery mechanisms
- Graceful degradation for unsupported features